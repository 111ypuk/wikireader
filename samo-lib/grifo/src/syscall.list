;;; syscall.list        -*- scheme -*-

;;; grifo - a small kernel for WikiReader
;;;
;;; Copyright (c) 2009 Christopher Hall <hsw@openmoko.com>
;;;
;;; This program is free software: you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation, either version 3 of the License, or
;;; (at your option) any later version.
;;;
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;
;;; You should have received a copy of the GNU General Public License
;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; File format:
;;;
;;; A. Command
;;;    1 = command name
;;;    rest = command arguments
;;;
;;; B. System Call
;;;    1 = system call number 0..n in increments of 1
;;;    2 = Grifo internal function name
;;;    3 = list (type function arguments)
;;;    4 = optional attributes

(
 ;; GPLV3+
 (copy-all "src/license.i")

 (ifnot _GRIFO_H_)

 (include<> inttypes.h)
 (include<> stdbool.h)
 (include<> stdlib.h)

 (output "typedef int32_t ssize_t;")

 ;; functions
 ;(0 "panic" ("void" "panic" "const char *message"))

 (section "console debugging")
 (1 Serial_print   ("void" "debug_print" "const char *message"))
 (2 Serial_PutChar ("int" "debug_printchar" "int c"))
 (3 Serial_printf  ("int" "debug_printf" "const char *format" "...") "__attribute__ ((format (printf, 1, 2)))")


 (section "interrupt handlers")

 (output "typedef enum {")
 (copy-part "src/vector.h" "vectors")
 (output "} vector_t;")
 (newline)
 (output "typedef void interrupt_handler(void);")
 (newline)

 (10 Vector_get ("interrupt_handler *" "vector_get" "vector_t vector_number"))
 (11 Vector_set ("interrupt_handler *" "vector_set" "vector_t vector_number" "interrupt_handler *vector"))


 (section "critcal sections")

 (output "typedef uint32_t critical_t;")
 (newline)

 (prototype ("inline critical_t" "critcal_enter" "void"))
 (copy-part "src/interrupt.h" "enter")
 (newline)

 (prototype ("inline void" "critical_exit" "critical_t state"))
 (copy-part "src/interrupt.h" "exit")


 (section "timer and delay")

 (20 Delay_microseconds ("void" "delay_us" "unsigned long microseconds"))

 (copy-part "src/timer.h" "enum")
 (newline)
 (24 Timer_get ("unsigned long" "timer_get" "void"))


 ;; WATCHDOG MISSING......


 (section "event queue")
 (copy-part "src/event.h" "types")
 (newline)

 (30 Event_flush ("void" "event_flush" "void"))
 ;;(31 Event_clear ("void" "event_flush" "event_item_t item_type"))

 ;;(35 Event_available ("bool" "event_avail" "event_item_t item_type"));

 (remark "get the next event if available otherwise return EVENT_NONE" "xxxx")
 (36 Event_get ("event_item_t" "event_get" "event_t *event"))


 (section "LCD access")

 (copy-part "src/LCD.h" "types")

 (40 LCD_GetFrameBuffer ("uint8_t *" "lcd_get_framebuffer" "void"))

 (remark "frame buffer must be word aligned")
 (41 LCD_SetFrameBuffer ("uint32_t *" "lcd_set_framebuffer" "uint32_t *address"))


 (42 LCD_AllWhite ("void" "lcd_clear" "void"))
 (43 LCD_AllBlack ("void" "lcd_clear_reverse" "void"))

 (newline)
 (output "typedef enum {")
 (copy-part "src/LCD.h" "colours")
 (output "} lcd_colour_t;")

 (44 LCD_GetPixel ("lcd_colour_t" "lcd_get_pixel" "int x" "int y"))
 (45 LCD_SetPixel ("void" "lcd_set_pixel" "int x" "int y" "lcd_colour_t colour"))

 (46 LCD_line ("void" "lcd_line" "int x0" "int y0" "int x1" "int y1" "lcd_colour_t colour"))

 ;;(47 LCD_AtXY ("void" "lcd_at_xy" "int x" "int y"))
 ;;(48 LCD_printf  ("int" "lcd_printf" "const char *format" "...") "__attribute__ ((format (printf, 1, 2)))")


 (section "Files and Directory access")

 (output "typedef enum {")
 (copy-part "src/file.h" "access")
 (output "} file_access_t;")

 (output "typedef enum {")
 (copy-part "src/file.h" "error")
 (output "} file_error_t;")

 (60 File_CloseAll ("void" "file_close_all" "void"))

 (61 File_rename ("file_error_t" "file_rename" "const char *OldFilename" "const char *NewFilename"))
 (62 File_delete ("file_error_t" "file_delete" "const char *filename"))
 (63 File_size ("file_error_t" "file_size"" const char *filename" "unsigned long *length"))

 (70 File_create ("file_error_t" "file_create" "const char *filename" "file_access_t fam"))

 (71 File_open ("file_error_t" "file_open" "const char *filename" "file_access_t fam"))
 (72 File_close ("file_error_t" "file_close" "int handle"))
 (73 File_read ("ssize_t" "file_read" "int handle" "void *buffer" "size_t length"))
 (74 File_write ("ssize_t" "file_write" "int handle" "void *buffer" "size_t length"))
 (75 File_sync ("file_error_t" "file_sync" "int handle"))
 (76 File_lseek ("file_error_t" "file_lseek" "int handle" "unsigned long pos"))
 ;;(67 File_ltell ("file_error_t" "file_ltell" "int handle" "unsigned long *pos"))

 ;;(80 File_ChangeDirectory ("file_error_t" "directory_chdir" "const char *directoryname"))
 ;;(81 File_CurrentDirectory ("file_error_t" "directory_cwd" "char *directoryname" "size_t length"))
 (81 File_CreateDirectory ("file_error_t" "directory_create" "const char *directoryname"))
 (82 File_OpenDirectory ("file_error_t" "directory_open" "const char *directoryname"))
 (83 File_CloseDirectory ("file_error_t" "directory_close" "int handle"))
 (84 File_ReadDirectory ("ssize_t" "directory_read" "int handle" "void *buffer" "size_t length"))

 (90 File_AbsoluteRead ("file_error_t" "sector_read" "unsigned long sector" "void *buffer" "int count"))
 (91 File_AbsoluteWrite ("file_error_t" "sector_write" "unsigned long sector" "const void *buffer" "int count"))


 (endif)
)
