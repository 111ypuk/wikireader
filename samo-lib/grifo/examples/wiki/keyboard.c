/*
 * Copyright (c) 2009 Openmoko Inc.
 *
 * Authors   Holger Hans Peter Freyther <zecke@openmoko.org>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <ctype.h>

#include <grifo.h>

#include "string.h"
#include "keyboard.h"
#include "guilib.h"
#include "wikilib.h"
#include "wiki_info.h"
#include "search.h"
#include "glyph.h"
#include "utf8.h"
#include "languages.h"

// definition for all the keyboard images generated by the Makefile
// files line keyboard_abc.png will result in a keyboard_abc_image variable
// included via all_images.h (see mahatma/build for generated headers)
#define LCD_ImageType static struct guilib_image
#define bytes data
#include "all_images.h"
#undef LCD_ImageType
#undef bytes

#define DBG_KEYBOARD 0

static struct guilib_image *image_data;
int keyboard_type = 0;
int b_first_123_keyin = 0;
unsigned long key_bubble_start_time = 0;
int bIsKoreanSpecialKey = 0;
int bKoreanSpecialKeyEnabled = 0;
extern int display_mode;
extern unsigned int touch_down_on_keyboard;
extern int b_type_a_word_cleared;

/* qwerty keyboard by columns */
#define KEY(l_x, l_y, r_x, r_y, l_x_i, l_y_i, r_x_i, r_y_i, keycode)	\
	{               .left_x = l_x, .right_x = r_x,                  \
			.left_y = l_y, .right_y = r_y,                  \
			.left_x_inverted = l_x_i, .right_x_inverted = r_x_i, \
			.left_y_inverted = l_y_i, .right_y_inverted = r_y_i, \
			.key = 	(const unsigned char *)keycode,         \
			}

static struct keyboard_key qwerty_char[] = {
	KEY(  0, 126,  23, 152,	  3, 128,  21, 150,	"q"),
	KEY(  0, 153,  23, 180,	  3, 156,  21, 178,	"a"),
	KEY(  0, 181,  23, 207,	  3, 183,  21, 205,	"z"),

	KEY( 24, 126,  47, 152,	 26, 128,  45, 150,	"w"),
	KEY( 24, 153,  47, 180,	 26, 156,  45, 178,	"s"),
	KEY( 24, 181,  47, 207,	 26, 183,  45, 205,	"x"),

	KEY( 48, 126,  71, 152,	 50, 128,  69, 150,	"e"),
	KEY( 48, 153,  71, 180,	 50, 156,  69, 178,	"d"),
	KEY( 48, 181,  71, 207,	 50, 183,  69, 205,	"c"),

	KEY( 72, 126, 95, 152,	 74, 128,  93, 150,	"r"),
	KEY( 72, 153, 95, 180,	 74, 156,  93, 178,	"f"),
	KEY( 72, 181, 95, 207,	 74, 183,  93, 205,	"v"),

	KEY( 96, 126, 119, 152,	 98, 128, 117, 150,	"t"),
	KEY( 96, 153, 119, 180,	 98, 156, 117, 178,	"g"),
	KEY( 96, 181, 143, 207,	 98, 184, 141, 205,	" "),

	KEY(120, 126, 143, 152,	122, 128, 141, 150,	"y"),
	KEY(120, 153, 143, 180,	122, 156, 141, 178,	"h"),

	KEY(144, 126, 167, 152,	146, 128, 165, 150,	"u"),
	KEY(144, 153, 167, 180,	146, 156, 165, 178,	"j"),
	KEY(144, 181, 167, 207,	146, 183, 165, 205,	"b"),

	KEY(168, 126, 191, 152,	170, 128, 189, 150,	"i"),
	KEY(168, 153, 191, 180,	170, 156, 189, 178,	"k"),
	KEY(168, 181, 191, 207,	170, 183, 189, 205,	"n"),

	KEY(192, 126, 215, 152,	194, 128, 213, 150,	"o"),
	KEY(192, 153, 215, 180,	194, 156, 213, 178,	"l"),
	KEY(192, 181, 215, 207,	194, 183, 213, 205,	"m"),

	KEY(216, 126, 239, 152,	218, 128, 236, 150,	"p"),
	KEY(216, 153, 239, 180,	218, 156, 236, 178,	WL_KEY_BACKSPACE_STR),
	KEY(216, 181, 239, 207,	218, 183, 236, 205,	WL_KEY_SWITCH_KEYBOARD_STR),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key qwerty_full_char[] = {
	KEY(  0, 126,  23, 152,	  3, 128,  21, 150,	"ｑ"),
	KEY(  0, 153,  23, 180,	  3, 156,  21, 178,	"ａ"),
	KEY(  0, 181,  23, 207,	  3, 183,  21, 205,	"ｚ"),

	KEY( 24, 126,  47, 152,	 26, 128,  45, 150,	"ｗ"),
	KEY( 24, 153,  47, 180,	 26, 156,  45, 178,	"ｓ"),
	KEY( 24, 181,  47, 207,	 26, 183,  45, 205,	"ｘ"),

	KEY( 48, 126,  71, 152,	 50, 128,  69, 150,	"ｅ"),
	KEY( 48, 153,  71, 180,	 50, 156,  69, 178,	"ｄ"),
	KEY( 48, 181,  71, 207,	 50, 183,  69, 205,	"ｃ"),

	KEY( 72, 126, 95, 152,	 74, 128,  93, 150,	"ｒ"),
	KEY( 72, 153, 95, 180,	 74, 156,  93, 178,	"ｆ"),
	KEY( 72, 181, 95, 207,	 74, 183,  93, 205,	"ｖ"),

	KEY( 96, 126, 119, 152,	 98, 128, 117, 150,	"ｔ"),
	KEY( 96, 153, 119, 180,	 98, 156, 117, 178,	"ｇ"),
	KEY( 96, 181, 143, 207,	 98, 184, 141, 205,	" "),

	KEY(120, 126, 143, 152,	122, 128, 141, 150,	"ｙ"),
	KEY(120, 153, 143, 180,	122, 156, 141, 178,	"ｈ"),

	KEY(144, 126, 167, 152,	146, 128, 165, 150,	"ｕ"),
	KEY(144, 153, 167, 180,	146, 156, 165, 178,	"ｊ"),
	KEY(144, 181, 167, 207,	146, 183, 165, 205,	"ｂ"),

	KEY(168, 126, 191, 152,	170, 128, 189, 150,	"ｉ"),
	KEY(168, 153, 191, 180,	170, 156, 189, 178,	"ｋ"),
	KEY(168, 181, 191, 207,	170, 183, 189, 205,	"ｎ"),

	KEY(192, 126, 215, 152,	194, 128, 213, 150,	"ｏ"),
	KEY(192, 153, 215, 180,	194, 156, 213, 178,	"ｌ"),
	KEY(192, 181, 215, 207,	194, 183, 213, 205,	"ｍ"),

	KEY(216, 126, 239, 152,	218, 128, 236, 150,	"ｐ"),
	KEY(216, 153, 239, 180,	218, 156, 236, 178,	WL_KEY_BACKSPACE_STR),
	KEY(216, 181, 239, 207,	218, 183, 236, 205,	WL_KEY_SWITCH_KEYBOARD_STR),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key qwerty_char_da[] = {
	KEY(  0, 126,  20, 152,	  1, 128,  19, 150,	"ｑ"),
	KEY(  0, 153,  20, 180,	  1, 156,  19, 178,	"ａ"),
	KEY(  0, 181,  20, 207,	  1, 183,  19, 205,	"ｚ"),

	KEY( 21, 126,  42, 152,	 22, 128,  41, 150,	"ｗ"),
	KEY( 21, 153,  42, 180,	 22, 156,  41, 178,	"ｓ"),
	KEY( 21, 181,  42, 207,	 22, 183,  41, 205,	"ｘ"),

	KEY( 43, 126,  64, 152,	 44, 128,  63, 150,	"ｅ"),
	KEY( 43, 153,  64, 180,	 44, 156,  63, 178,	"ｄ"),
	KEY( 43, 181,  64, 207,	 44, 183,  63, 205,	"ｃ"),

	KEY( 65, 126, 86, 152,	 66, 128,  85, 150,	"ｒ"),
	KEY( 65, 153, 86, 180,	 66, 156,  85, 178,	"ｆ"),
	KEY( 65, 181, 86, 207,	 66, 183,  85, 205,	"ｖ"),

	KEY( 87, 126, 108, 152,	 88, 128, 107, 150,	"ｔ"),
	KEY( 87, 153, 108, 180,	 88, 156, 107, 178,	"ｇ"),
	KEY( 87, 181, 130, 207,	 88, 184, 129, 205,	" "),

	KEY(109, 126, 130, 152,	110, 128, 129, 150,	"ｙ"),
	KEY(109, 153, 130, 180,	110, 156, 129, 178,	"ｈ"),

	KEY(131, 126, 152, 152,	132, 128, 151, 150,	"ｕ"),
	KEY(131, 153, 152, 180,	132, 156, 151, 178,	"ｊ"),
	KEY(131, 181, 152, 207,	132, 183, 151, 205,	"ｂ"),

	KEY(153, 126, 174, 152,	154, 128, 173, 150,	"ｉ"),
	KEY(153, 153, 174, 180,	154, 156, 173, 178,	"ｋ"),
	KEY(153, 181, 174, 207,	154, 183, 173, 205,	"ｎ"),

	KEY(175, 126, 196, 152,	176, 128, 195, 150,	"ｏ"),
	KEY(175, 153, 196, 180,	176, 156, 195, 178,	"ｌ"),
	KEY(175, 181, 196, 207,	176, 183, 195, 205,	"ｍ"),

	KEY(197, 126, 218, 152,	198, 128, 217, 150,	"ｐ"),
	KEY(197, 153, 218, 180,	198, 156, 217, 178,	"æ"),
	KEY(197, 181, 218, 207,	198, 183, 217, 205,	WL_KEY_SWITCH_KEYBOARD_STR),

	KEY(219, 126, 239, 152,	220, 128, 238, 150,	"å"),
	KEY(219, 153, 239, 180,	220, 156, 238, 178,	"ø"),
	KEY(219, 181, 239, 207,	220, 183, 238, 205,	WL_KEY_BACKSPACE_STR),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key qwerty_num[] = {
	KEY(  0, 126,  23, 152,	  3, 128,  21, 150,	"1"),
	KEY(  0, 153,  23, 180,	  3, 156,  21, 178,	"*"),
	KEY(  0, 181,  23, 207,	  3, 183,  21, 205,	"@"),

	KEY( 24, 126,  47, 152,	 26, 128,  45, 150,	"2"),
	KEY( 24, 153,  47, 180,	 26, 156,  45, 178,	"$"),
	KEY( 24, 181,  47, 207,	 26, 183,  45, 205,	"?"),

	KEY( 48, 126,  71, 152,	 50, 128,  69, 150,	"3"),
	KEY( 48, 153,  71, 180,	 50, 156,  69, 178,	"%"),
	KEY( 48, 181,  71, 207,	 50, 183,  69, 205,	"!"),

	KEY( 72, 126, 95, 152,	 74, 128,  93, 150,	"4"),
	KEY( 72, 153, 95, 180,	 74, 156,  93, 178,	"#"),
	KEY( 72, 181, 95, 207,	 74, 183,  93, 205,	"&"),

	KEY( 96, 126, 119, 152,	 98, 128, 117, 150,	"5"),
	KEY( 96, 153, 119, 180,	 98, 156, 117, 178,	"("),
	KEY( 96, 181, 143, 207,	 98, 184, 141, 205,	" "),

	KEY(120, 126, 143, 152,	122, 128, 141, 150,	"6"),
	KEY(120, 153, 143, 180,	122, 156, 141, 178,	")"),

	KEY(144, 126, 167, 152,	146, 128, 165, 150,	"7"),
	KEY(144, 153, 167, 180,	146, 156, 165, 178,	"-"),
	KEY(144, 181, 167, 207,	146, 183, 165, 205,	","),

	KEY(168, 126, 191, 152,	170, 128, 189, 150,	"8"),
	KEY(168, 153, 191, 180,	170, 156, 189, 178,	"+"),
	KEY(168, 181, 191, 207,	170, 183, 189, 205,	"."),

	KEY(192, 126, 215, 152,	194, 128, 213, 150,	"9"),
	KEY(192, 153, 215, 180,	194, 156, 213, 178,	"="),
	KEY(192, 181, 215, 207,	194, 183, 213, 205,	"'"),

	KEY(216, 126, 239, 152,	218, 128, 236, 150,	"0"),
	KEY(216, 153, 239, 180,	218, 156, 236, 178,	WL_KEY_BACKSPACE_STR),
	KEY(216, 181, 239, 207,	218, 183, 236, 205,	WL_KEY_SWITCH_KEYBOARD_STR),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key phone_jp[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"あいうえおぁぃぅぇぉ"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"かきくけこ"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"さしすせそ"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"たちつてとっ"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"なにぬねの"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"はひふへほ"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_ABC_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"まみむめも"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"やゆよゃゅょ"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"らりるれろ"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_123_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	WL_KEY_SONANT_STR),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"わをんゎー"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"、。?!"),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};

static struct keyboard_key phone_tw[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"ㄅㄆㄇㄈ"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"ㄉㄊㄋㄌ"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"ㄍㄎㄏ"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"ㄐㄑㄒ"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"ㄓㄔㄕㄖ"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"ㄗㄘㄙ"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_ABC_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"ㄚㄛㄜㄝ"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"ㄞㄟㄠㄡ"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"ㄢㄣㄤㄥㄦ"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_123_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	"+－*="),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"ㄧㄨㄩ"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"，‧?!"),

	KEY(198,  84, 233, 119,	198,  84, 233, 119,	WL_KEY_NLS_STR),
};

static struct keyboard_key phone_abc[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"@#$%&"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"ａｂｃ"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"ｄｅｆ"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"ｇｈｉ"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"ｊｋｌ"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"ｍｎｏ"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_DEFAULT_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"ｐｑｒｓ"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"ｔｕｖ"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"ｗｘｙｚ"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_123_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	"+－*="),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"'()"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"、。?!"),

	KEY(198, 84, 233, 119,	198, 84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key phone_123[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"1"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"2"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"3"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"4"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"5"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"6"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_ABC_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"7"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"8"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"9"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_DEFAULT_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	"+－*="),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"0"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"、。?!"),

	KEY(198, 84, 233, 119,	198, 84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key phone_tw_abc[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"@#$%&"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"ａｂｃ"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"ｄｅｆ"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"ｇｈｉ"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"ｊｋｌ"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"ｍｎｏ"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_DEFAULT_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"ｐｑｒｓ"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"ｔｕｖ"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"ｗｘｙｚ"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_123_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	"+－*="),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"'()"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"，‧?!"),

	KEY(198, 84, 233, 119,	198, 84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key phone_tw_123[] = {
	KEY(  0, 127,  45, 146,	  2, 128,  43, 145,	WL_KEY_NO_WAIT_STR),
	KEY( 46, 127,  94, 146,	 48, 129,  93, 145,	"1"),
	KEY( 95, 127, 143, 146,	 97, 129, 142, 145,	"2"),
	KEY(144, 127, 193, 146,	146, 129, 191, 145,	"3"),
	KEY(194, 127, 239, 146,	196, 128, 237, 145,	WL_KEY_BACKSPACE_STR),

	KEY(  0, 147,  45, 166,	  2, 149,  43, 165,	WL_KEY_BACKWARD_STR),
	KEY( 46, 147,  94, 166,	 48, 149,  93, 165,	"4"),
	KEY( 95, 147, 143, 166,	 97, 149, 142, 165,	"5"),
	KEY(144, 147, 193, 166,	146, 149, 191, 165,	"6"),
	KEY(194, 147, 239, 166,	196, 149, 237, 165,	WL_KEY_CLEAR_STR),

	KEY(  0, 167,  45, 186,	  2, 169,  43, 185,	WL_KEY_POHONE_STYLE_KEYBOARD_ABC_STR),
	KEY( 46, 167,  94, 186,	 48, 169,  93, 185,	"7"),
	KEY( 95, 167, 143, 186,	 97, 169, 142, 185,	"8"),
	KEY(144, 167, 193, 186,	146, 169, 191, 185,	"9"),
	KEY(194, 167, 239, 207,	196, 169, 237, 206,	" "),

	KEY(  0, 187,  45, 207,	  2, 189,  43, 206,	WL_KEY_POHONE_STYLE_KEYBOARD_DEFAULT_STR),
	KEY( 46, 187,  94, 207,	 48, 189,  93, 205,	"+－*="),
	KEY( 95, 187, 143, 207,	 97, 189, 142, 205,	"0"),
	KEY(144, 187, 193, 207,	146, 189, 191, 205,	"，‧?!"),

	KEY(198, 84, 233, 119,	198, 84, 233, 119,	WL_KEY_NLS_STR),
};
static struct keyboard_key password_char[] = {
	KEY(175, 81, 204, 105,	177, 83, 202, 103,	"Y"),

	KEY(  0, 126,  23, 152,	  3, 128,  21, 150,	"q"),
	KEY(  0, 153,  23, 180,	  3, 156,  21, 178,	"a"),
	KEY(  0, 181,  23, 207,	  3, 183,  21, 205,	"z"),

	KEY( 24, 126,  47, 152,	 26, 128,  45, 150,	"w"),
	KEY( 24, 153,  47, 180,	 26, 156,  45, 178,	"s"),
	KEY( 24, 181,  47, 207,	 26, 183,  45, 205,	"x"),

	KEY( 48, 126,  71, 152,	 50, 128,  69, 150,	"e"),
	KEY( 48, 153,  71, 180,	 50, 156,  69, 178,	"d"),
	KEY( 48, 181,  71, 207,	 50, 183,  69, 205,	"c"),

	KEY( 72, 126, 95, 152,	 74, 128,  93, 150,	"r"),
	KEY( 72, 153, 95, 180,	 74, 156,  93, 178,	"f"),
	KEY( 72, 181, 95, 207,	 74, 183,  93, 205,	"v"),

	KEY( 96, 126, 119, 152,	 98, 128, 117, 150,	"t"),
	KEY( 96, 153, 119, 180,	 98, 156, 117, 178,	"g"),
	KEY( 96, 181, 143, 207,	 98, 184, 141, 205,	" "),

	KEY(120, 126, 143, 152,	122, 128, 141, 150,	"y"),
	KEY(120, 153, 143, 180,	122, 156, 141, 178,	"h"),

	KEY(144, 126, 167, 152,	146, 128, 165, 150,	"u"),
	KEY(144, 153, 167, 180,	146, 156, 165, 178,	"j"),
	KEY(144, 181, 167, 207,	146, 183, 165, 205,	"b"),

	KEY(168, 126, 191, 152,	170, 128, 189, 150,	"i"),
	KEY(168, 153, 191, 180,	170, 156, 189, 178,	"k"),
	KEY(168, 181, 191, 207,	170, 183, 189, 205,	"n"),

	KEY(192, 126, 215, 152,	194, 128, 213, 150,	"o"),
	KEY(192, 153, 215, 180,	194, 156, 213, 178,	"l"),
	KEY(192, 181, 215, 207,	194, 183, 213, 205,	"m"),

	KEY(216, 126, 239, 152,	218, 128, 236, 150,	"p"),
	KEY(216, 153, 239, 180,	218, 156, 236, 178,	WL_KEY_BACKSPACE_STR),
	KEY(216, 181, 239, 207,	218, 183, 236, 205,	WL_KEY_SWITCH_KEYBOARD_STR),
};
static struct keyboard_key password_num[] = {
	KEY(175, 81, 204, 105,	175, 81, 204, 105,	"Y"),

	KEY(  0, 126,  23, 152,	  3, 128,  21, 150,	"1"),
	KEY(  0, 153,  23, 180,	  3, 156,  21, 178,	"*"),
	KEY(  0, 181,  23, 207,	  3, 183,  21, 205,	"@"),

	KEY( 24, 126,  47, 152,	 26, 128,  45, 150,	"2"),
	KEY( 24, 153,  47, 180,	 26, 156,  45, 178,	"$"),
	KEY( 24, 181,  47, 207,	 26, 183,  45, 205,	"?"),

	KEY( 48, 126,  71, 152,	 50, 128,  69, 150,	"3"),
	KEY( 48, 153,  71, 180,	 50, 156,  69, 178,	"%"),
	KEY( 48, 181,  71, 207,	 50, 183,  69, 205,	"!"),

	KEY( 72, 126, 95, 152,	 74, 128,  93, 150,	"4"),
	KEY( 72, 153, 95, 180,	 74, 156,  93, 178,	"#"),
	KEY( 72, 181, 95, 207,	 74, 183,  93, 205,	"&"),

	KEY( 96, 126, 119, 152,	 98, 128, 117, 150,	"5"),
	KEY( 96, 153, 119, 180,	 98, 156, 117, 178,	"("),
	KEY( 96, 181, 143, 207,	 98, 184, 141, 205,	" "),

	KEY(120, 126, 143, 152,	122, 128, 141, 150,	"6"),
	KEY(120, 153, 143, 180,	122, 156, 141, 178,	")"),

	KEY(144, 126, 167, 152,	146, 128, 165, 150,	"7"),
	KEY(144, 153, 167, 180,	146, 156, 165, 178,	"-"),
	KEY(144, 181, 167, 207,	146, 183, 165, 205,	","),

	KEY(168, 126, 191, 152,	170, 128, 189, 150,	"8"),
	KEY(168, 153, 191, 180,	170, 156, 189, 178,	"+"),
	KEY(168, 181, 191, 207,	170, 183, 189, 205,	"."),

	KEY(192, 126, 215, 152,	194, 128, 213, 150,	"9"),
	KEY(192, 153, 215, 180,	194, 156, 213, 178,	"="),
	KEY(192, 181, 215, 207,	194, 183, 213, 205,	"'"),

	KEY(216, 126, 239, 152,	218, 128, 236, 150,	"0"),
	KEY(216, 153, 239, 180,	218, 156, 236, 178,	WL_KEY_BACKSPACE_STR),
	KEY(216, 181, 239, 207,	218, 183, 236, 205,	WL_KEY_SWITCH_KEYBOARD_STR),
};
static struct keyboard_key clear_history[] = {
	KEY(131, 181, 184, 207,	133, 183, 182, 205,	"Y"),
	KEY(185, 181, 238, 207,	187, 183, 236, 205,	"N"),
};
static struct keyboard_key restriction[] = {
	KEY(12, 148, 227, 170,	14, 150, 225, 168,	"Y"),
};
static struct keyboard_key filter_on_off[] = {
	KEY(12, 134, 227, 157,	14, 136, 225, 155,	"Y"),
	KEY(12, 163, 227, 186,	14, 165, 225, 184,	"N"),
};
static struct keyboard_key filter_option[] = {
	KEY(12, 105, 227, 128,	14, 107, 225, 126,	"Y"),
	KEY(12, 134, 227, 157,	14, 136, 225, 155,	"N"),
	KEY(12, 163, 227, 187,	14, 165, 225, 185,	"P"),
};
/*
 * The secret of the position and size of the keyboard
 * is shared between search.c and this file.
 */

#define KEY_BUBBLE_STEM_UNDER_KEYPAD_PIXELS 4
#define KEY_BUBBLE_TOTAL_HEIGHT 57
#define KEY_BUBBLE_TOTAL_WIDTH 28
#define KEY_BUBBLE_TOTAL_WIDTH_BYTES ((KEY_BUBBLE_TOTAL_WIDTH + 7) / 8 + 1)
#define KEY_BUBBLE_STEM_WIDTH 22
#define KEY_BUBBLE_STEM_HEIGHT 18
#define KEY_BUBBLE_CONDITIONAL_RESTORE_HEIGHT 30
#define KEY_BUBBLE_STAY_TIME 0.2
#define KOREAN_SPECIAL_KEY_CHANGE_TIME 1
static struct keyboard_key *pre_key = NULL;
static int keyboard_key_invert_dalay = 0;
static char key_bubble_save[KEY_BUBBLE_TOTAL_HEIGHT * KEY_BUBBLE_TOTAL_WIDTH_BYTES];
static int key_bubble_save_x_start_byte;
static int key_bubble_save_y_start;
static int key_bubble_save_width_bytes;

static KEYBOARD_MODE kb_mode = KEYBOARD_CHAR;
extern unsigned char *framebuffer;

int is_korean_special_key(struct keyboard_key *key)
{
	if (strchr("eopqrtw", *key->key))
		return 1;
	else
		return 0;
}

int is_korean_special_key_enabled()
{
	if (bIsKoreanSpecialKey && bKoreanSpecialKeyEnabled)
		return 1;
	else
		return 0;
}

void keyboard_set_mode(int mode)
{
	kb_mode = mode;

	if(kb_mode == KEYBOARD_CHAR) {
		if (wiki_is_japanese())
			image_data = &keyboard_abc2_jp_image;
		else if (wiki_is_korean())
			image_data = &keyboard_abc2_ko_image;
		else
			image_data = &keyboard_abc_image;
	} else if(kb_mode == KEYBOARD_PASSWORD_CHAR) {
		image_data = &keyboard_abc_image;
	} else if(kb_mode == KEYBOARD_CHAR_JP) {
		image_data = &keyboard_abc_image;
	} else if (kb_mode == KEYBOARD_CHAR_KO) {
		image_data = &keyboard_abc_ko_image;
	} else if (kb_mode == KEYBOARD_CHAR_DA) {
		image_data = &keyboard_abc_da_image;
	} else if(kb_mode == KEYBOARD_NUM || kb_mode == KEYBOARD_PASSWORD_NUM) {
		image_data = &keyboard_123_image;
		b_first_123_keyin = 1;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_JP) {
		image_data = &keyboard_phone_jp_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_ABC) {
		if (wiki_is_TC())
			image_data = &keyboard_phone_tw_abc_image;
		else
			image_data = &keyboard_phone_jp_abc_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_123) {
		if (wiki_is_TC())
			image_data = &keyboard_phone_tw_123_image;
		else
			image_data = &keyboard_phone_jp_123_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_TW) {
		image_data = &keyboard_phone_tw_image;
	} else {
		image_data = NULL;
	}
}

int keyboard_get_mode()
{
	return kb_mode;
}

int nls_button_enabled()
{
	return (get_search_string_len() == 0 && get_wiki_count() > 1);
}


void keyboard_paint()
{
	pre_key = NULL;
	if(kb_mode == KEYBOARD_CHAR)
	{
		if (wiki_is_japanese())
			image_data = &keyboard_abc2_jp_image;
		else if (wiki_is_korean())
			image_data = &keyboard_abc2_ko_image;
		else
			image_data = &keyboard_abc_image;
	} else if(kb_mode == KEYBOARD_PASSWORD_CHAR) {
		image_data = &keyboard_abc_image;
	} else if(kb_mode == KEYBOARD_CHAR_JP) {
		image_data = &keyboard_abc_image;
	} else if (kb_mode == KEYBOARD_CHAR_KO) {
		image_data = &keyboard_abc_ko_image;
	} else if (kb_mode == KEYBOARD_CHAR_DA) {
		image_data = &keyboard_abc_da_image;
	} else if(kb_mode == KEYBOARD_NUM || kb_mode == KEYBOARD_PASSWORD_NUM) {
		image_data = &keyboard_123_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_JP) {
		image_data = &keyboard_phone_jp_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_TW) {
		image_data = &keyboard_phone_tw_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_ABC) {
		if (wiki_is_TC())
			image_data = &keyboard_phone_tw_abc_image;
		else
			image_data = &keyboard_phone_jp_abc_image;
	} else if(kb_mode == KEYBOARD_PHONE_STYLE_123) {
		if (wiki_is_TC())
			image_data = &keyboard_phone_tw_123_image;
		else
			image_data = &keyboard_phone_jp_123_image;
	} else {
		return;
	}

	guilib_fb_lock();
	guilib_blit_image(image_data, 0, guilib_framebuffer_height() - image_data->height);
	if (nls_button_enabled())
		guilib_blit_image(&nls_image, 200, guilib_framebuffer_height() - image_data->height - 40);
	guilib_fb_unlock();
}

unsigned int keyboard_height()
{
	if (!image_data)
		return 0;
	else
		return image_data->height;
}

struct keyboard_key * keyboard_get_data(int x, int y)
{
	int i;
	struct keyboard_key *keyboard_key = NULL;
	int keyboard_entries = 0;

	if (touch_down_on_keyboard && pre_key &&
	    pre_key->left_x - (pre_key->right_x - pre_key->left_x) / 2 <= x && x <= pre_key->right_x + (pre_key->right_x - pre_key->left_x) / 2 &&
	    pre_key->left_y - (pre_key->right_y - pre_key->left_y) / 2 <= y && y <= pre_key->right_y + (pre_key->right_y - pre_key->left_y) / 2 )
		return pre_key;

	if (kb_mode == KEYBOARD_CHAR)
	{
		if (wiki_is_japanese() || wiki_is_korean())
		{
			keyboard_key = qwerty_full_char;
			keyboard_entries = ARRAY_SIZE(qwerty_full_char);
		}
		else
		{
			keyboard_key = qwerty_char;
			keyboard_entries = ARRAY_SIZE(qwerty_char);
		}
	}
	else if (kb_mode == KEYBOARD_CHAR_JP)
	{
		keyboard_key = qwerty_char;
		keyboard_entries = ARRAY_SIZE(qwerty_char);
	}
	else if (kb_mode == KEYBOARD_CHAR_KO)
	{
		keyboard_key = qwerty_char;
		keyboard_entries = ARRAY_SIZE(qwerty_char);
	}
	else if (kb_mode == KEYBOARD_CHAR_DA)
	{
		keyboard_key = qwerty_char_da;
		keyboard_entries = ARRAY_SIZE(qwerty_char_da);
	}
	else if (kb_mode == KEYBOARD_NUM)
	{
		keyboard_key = qwerty_num;
		keyboard_entries = ARRAY_SIZE(qwerty_num);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_JP)
	{
		keyboard_key = phone_jp;
		keyboard_entries = ARRAY_SIZE(phone_jp);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_TW)
	{
		keyboard_key = phone_tw;
		keyboard_entries = ARRAY_SIZE(phone_tw);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_ABC)
	{
		if (wiki_is_TC())
		{
			keyboard_key = phone_tw_abc;
			keyboard_entries = ARRAY_SIZE(phone_tw_abc);
		}
		else
		{
			keyboard_key = phone_abc;
			keyboard_entries = ARRAY_SIZE(phone_abc);
		}
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_123)
	{
		if (wiki_is_TC())
		{
			keyboard_key = phone_tw_123;
			keyboard_entries = ARRAY_SIZE(phone_tw_123);
		}
		else
		{
			keyboard_key = phone_123;
			keyboard_entries = ARRAY_SIZE(phone_123);
		}
	}
	else if (kb_mode == KEYBOARD_CLEAR_HISTORY)
	{
		keyboard_key = clear_history;
		keyboard_entries = ARRAY_SIZE(clear_history);
	}
	else if (kb_mode == KEYBOARD_PASSWORD_CHAR)
	{
		keyboard_key = password_char;
		keyboard_entries = ARRAY_SIZE(password_char);
	}
	else if (kb_mode == KEYBOARD_PASSWORD_NUM)
	{
		keyboard_key = password_num;
		keyboard_entries = ARRAY_SIZE(password_num);
	}
	else if (kb_mode == KEYBOARD_RESTRICTED)
	{
		keyboard_key = restriction;
		keyboard_entries = ARRAY_SIZE(restriction);
	}
	else if (kb_mode == KEYBOARD_FILTER_ON_OFF)
	{
		keyboard_key = filter_on_off;
		keyboard_entries = ARRAY_SIZE(filter_on_off);
	}
	else if (kb_mode == KEYBOARD_FILTER_OPTION)
	{
		keyboard_key = filter_option;
		keyboard_entries = ARRAY_SIZE(filter_option);
	}

	if (keyboard_key)
	{
		for (i = 0; i < keyboard_entries; ++i) {
			if (keyboard_key[i].left_x <= x && keyboard_key[i].right_x >= x
			    && keyboard_key[i].left_y <= y && keyboard_key[i].right_y >= y
			    && (nls_button_enabled() || *keyboard_key[i].key != WL_KEY_NLS)) {
				return &keyboard_key[i];
			}
		}
	}
	return NULL;
}

void draw_key_bubble(int start_x, int start_y, int end_x, int end_y, unsigned char *key, int bOverwrite)
{
	(void)end_y; // *** unused argument
	int i, j;
	int bubble_start_x, bubble_start_y, bubble_end_x, bubble_end_y;
	int bubble_stem_start_x, bubble_stem_start_y, bubble_stem_end_x, bubble_stem_end_y;
	int bubble_stem_left_diff, bubble_stem_right_diff;
	unsigned char s[5];
	int width;
	int bubble_adjust = 0;
	int bubble_stem_width = end_x - start_x + 3;
	uint8_t *framebuffer = lcd_get_framebuffer();

	guilib_fb_lock();
	bubble_start_x = start_x - (KEY_BUBBLE_TOTAL_WIDTH - (end_x - start_x + 1)) / 2;
	if (bubble_start_x < 0)
	{
		bubble_adjust = -bubble_start_x;
		bubble_start_x = 0;
	}
	else if (bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH > LCD_BUF_WIDTH_PIXELS)
	{
		bubble_adjust = -(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - LCD_BUF_WIDTH_PIXELS);
		bubble_start_x = LCD_BUF_WIDTH_PIXELS - KEY_BUBBLE_TOTAL_WIDTH;
	}
	bubble_start_y = start_y + KEY_BUBBLE_STEM_UNDER_KEYPAD_PIXELS + KEY_BUBBLE_STEM_HEIGHT - KEY_BUBBLE_TOTAL_HEIGHT;
	bubble_end_x = bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 1;
	bubble_end_y = bubble_start_y + KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT - 1;

	if (!bOverwrite)
	{
		bubble_stem_start_x = bubble_start_x - bubble_adjust + (KEY_BUBBLE_TOTAL_WIDTH - bubble_stem_width) / 2;
		bubble_stem_end_x = bubble_stem_start_x + bubble_stem_width - 1;
		bubble_stem_start_y = bubble_end_y + 1;
		bubble_stem_end_y = bubble_start_y + KEY_BUBBLE_TOTAL_HEIGHT - 1;

		bubble_stem_left_diff = bubble_stem_start_x - bubble_start_x - bubble_adjust;
		bubble_stem_right_diff = bubble_end_x - bubble_stem_end_x + bubble_adjust;

		key_bubble_save_x_start_byte = bubble_start_x / 8;
		key_bubble_save_y_start = bubble_start_y;
		key_bubble_save_width_bytes = KEY_BUBBLE_TOTAL_WIDTH_BYTES;
		if (key_bubble_save_x_start_byte + key_bubble_save_width_bytes > LCD_BUF_WIDTH_BYTES)
			key_bubble_save_width_bytes = LCD_BUF_WIDTH_BYTES - key_bubble_save_x_start_byte;
		for (i = 0; i < KEY_BUBBLE_TOTAL_HEIGHT; i++)
		{
			memcpy(&key_bubble_save[i * KEY_BUBBLE_TOTAL_WIDTH_BYTES],
			       &framebuffer[(key_bubble_save_y_start + i) * LCD_BUF_WIDTH_BYTES + key_bubble_save_x_start_byte], key_bubble_save_width_bytes);
		}

		for (i = 0; i < KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT; i++)
		{
			if (i == 0 || i == 1)
			{
				for (j = 2 - i; j < KEY_BUBBLE_TOTAL_WIDTH - 2 + i; j++)
					lcd_set_pixel(bubble_start_x + j, bubble_start_y + i, LCD_BLACK);
			}
			else if (i == 2)
			{
				lcd_set_pixel(bubble_start_x + 2 - i, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + 3 - i, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + 4 - i, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 3 + i, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 4 + i, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 5 + i, bubble_start_y + i, LCD_BLACK);
				for (j = 5 - i; j < KEY_BUBBLE_TOTAL_WIDTH - 5 + i; j++)
					lcd_set_pixel(bubble_start_x + j, bubble_start_y + i, LCD_WHITE);
			}
			else if (KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT - 3 <= i && i <= KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT - 1 )
			{
				int left_diff, right_diff;

				left_diff = bubble_stem_left_diff / (KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT - i);
				if (bubble_stem_left_diff && ! left_diff)
					left_diff = 1;
				bubble_stem_left_diff -= left_diff;
				right_diff = bubble_stem_right_diff / (KEY_BUBBLE_TOTAL_HEIGHT - KEY_BUBBLE_STEM_HEIGHT - i);
				if (bubble_stem_right_diff && ! right_diff)
					right_diff = 1;
				bubble_stem_right_diff -= right_diff;
				lcd_set_pixel(bubble_start_x + left_diff, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + left_diff + 1, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - right_diff - 1, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - right_diff - 2, bubble_start_y + i, LCD_BLACK);
				for (j = left_diff + 2; j < KEY_BUBBLE_TOTAL_WIDTH - right_diff - 2; j++)
					lcd_set_pixel(bubble_start_x + j, bubble_start_y + i, LCD_WHITE);
			}
			else
			{
				lcd_set_pixel(bubble_start_x, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + 1, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 1, bubble_start_y + i, LCD_BLACK);
				lcd_set_pixel(bubble_start_x + KEY_BUBBLE_TOTAL_WIDTH - 2, bubble_start_y + i, LCD_BLACK);
				for (j = 2; j < KEY_BUBBLE_TOTAL_WIDTH - 2; j++)
					lcd_set_pixel(bubble_start_x + j, bubble_start_y + i, LCD_WHITE);
			}
		}

		for (i = 0; i < KEY_BUBBLE_STEM_HEIGHT; i++) // drawn from the bottom of the stem
		{
			if (i == 0) // bottom
			{
				for (j = 3; j < bubble_stem_width - 3; j++)
					lcd_set_pixel(bubble_stem_start_x + j, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_BLACK);
			}
			else if (1 <= i && i <= 2)
			{
				lcd_set_pixel(bubble_stem_start_x + 3 - i, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_BLACK);
				lcd_set_pixel(bubble_stem_start_x + bubble_stem_width - 4 + i, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_BLACK);
				for (j = 4 - i; j < bubble_stem_width - 4 + i; j++)
					lcd_set_pixel(bubble_stem_start_x + j, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_WHITE);
			}
			else
			{
				lcd_set_pixel(bubble_stem_start_x, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_BLACK);
				lcd_set_pixel(bubble_stem_start_x + bubble_stem_width - 1, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_BLACK);
				for (j = 1; j < bubble_stem_width - 1; j++)
					lcd_set_pixel(bubble_stem_start_x + j, bubble_stem_start_y + (KEY_BUBBLE_STEM_HEIGHT - 1 - i), LCD_WHITE);
			}
		}
	}
	else
	{
		guilib_clear_area(bubble_start_x + 2, bubble_start_y + 2, bubble_end_x - 2, bubble_end_y - 2);
	}

	if (kb_mode == KEYBOARD_CHAR_KO)
		alphabet_to_korean_jamo(s, *key);
	else
		utf8_char_toupper(s, key);
	width = get_external_str_pixel_width(s, TITLE_FONT_IDX);
	render_string(TITLE_FONT_IDX, bubble_start_x + (KEY_BUBBLE_TOTAL_WIDTH - width) / 2, bubble_start_y + 1, s, 1, 0);
	guilib_fb_unlock();
}

void restore_key_bubble(void)
{
	int i;
	int y_start = 0;
	uint8_t *framebuffer = lcd_get_framebuffer();

	guilib_fb_lock();
	if (b_type_a_word_cleared && key_bubble_save_y_start <= LCD_HEIGHT - KEYBOARD_HEIGHT - KEY_BUBBLE_CONDITIONAL_RESTORE_HEIGHT + 5)
	{
		y_start = KEY_BUBBLE_CONDITIONAL_RESTORE_HEIGHT;
	}
	for (i = y_start; i < KEY_BUBBLE_TOTAL_HEIGHT; i++)
		memcpy(&framebuffer[(key_bubble_save_y_start + i) * LCD_BUF_WIDTH_BYTES + key_bubble_save_x_start_byte],
		       &key_bubble_save[i * KEY_BUBBLE_TOTAL_WIDTH_BYTES], key_bubble_save_width_bytes);
	guilib_fb_unlock();
}

void keyboard_process_key_invert(struct keyboard_key *key, bool bResetDelay)
{
	int start_x, start_y, end_x, end_y;

	start_x = key->left_x_inverted;
	start_y = key->left_y_inverted;
	end_x = key->right_x_inverted;
	end_y = key->right_y_inverted;

	if (*key->key == WL_KEY_NLS)
	{
		int y_diff, x_diff;

		for (y_diff = -2; y_diff <= (end_y - start_y) / 2; y_diff++)
		{
			if (y_diff == -2)
				x_diff = 13;
			else if (y_diff == -1)
				x_diff = 10;
			else if (y_diff == 0)
				x_diff = 7;
			else if (1 <= y_diff && y_diff <= 5)
				x_diff = 6 - y_diff;
			else if (y_diff == 6)
				x_diff = 1;
			else if (7 <= y_diff && y_diff <= 8)
				x_diff = 0;
			else if (9 <= y_diff && y_diff <= 11)
				x_diff = -1;
			else
				x_diff = -2;
			guilib_invert_area(start_x + x_diff, start_y + y_diff, end_x - x_diff, start_y + y_diff);
			guilib_invert_area(start_x + x_diff, end_y - y_diff, end_x - x_diff, end_y - y_diff);
		}
	}
	else if (kb_mode > KEYBOARD_PHONE_STYLE)
	{
		guilib_invert_area(start_x,start_y,end_x,end_y);
		guilib_invert_area(start_x,start_y,start_x,start_y);
		guilib_invert_area(start_x,end_y,start_x,end_y);
		guilib_invert_area(end_x,start_y,end_x,start_y);
		guilib_invert_area(end_x,end_y,end_x,end_y);
	}
	else if (*key->key == ' ' || *key->key == WL_KEY_BACKSPACE || isupper(*key->key))
	{
		guilib_invert_area(start_x,start_y,end_x,end_y);
		guilib_invert_area(start_x,start_y,start_x,start_y);
		guilib_invert_area(start_x,end_y,start_x,end_y);
		guilib_invert_area(end_x,start_y,end_x,start_y);
		guilib_invert_area(end_x,end_y,end_x,end_y);
	}
	else
	{
		if (kb_mode == KEYBOARD_CHAR_KO && is_korean_special_key(key))
		{
			bIsKoreanSpecialKey = 1;
			bKoreanSpecialKeyEnabled = 0;
			key_bubble_start_time = timer_get();
		}
		else
		{
			bIsKoreanSpecialKey = 0;
			bKoreanSpecialKeyEnabled = 0;
		}
		draw_key_bubble(start_x, start_y, end_x, end_y, full_alphabet_to_half(key->key, NULL), 0);
	}
	if (bResetDelay)
		keyboard_key_invert_dalay = 0;
}

// return values:
// 0 - no key inverted
// 1 - key without multiple selections inverted
// -1 - key with multiple selections inverted
int keyboard_key_inverted(void)
{
	if (pre_key)
	{
		if (multi_selection_key(pre_key))
			return -1;
		else
			return 1;
	}
	else
		return 0;
}

void flash_keyboard_key_invert(void)
{
	if (pre_key)
		keyboard_process_key_invert(pre_key, false);
}

void keyboard_key_invert(struct keyboard_key *key)
{
	guilib_fb_lock();
	if (key && (*key->key == WL_KEY_SWITCH_KEYBOARD ||
		    *key->key == WL_KEY_POHONE_STYLE_KEYBOARD_DEFAULT ||
		    *key->key == WL_KEY_POHONE_STYLE_KEYBOARD_ABC ||
		    *key->key == WL_KEY_POHONE_STYLE_KEYBOARD_123))
		pre_key = NULL;
	else
	{
		if (pre_key)
		{
			keyboard_key_reset_invert(KEYBOARD_RESET_INVERT_NOW, 0);
		}
		if (key)
		{
			keyboard_process_key_invert(key, true);
			pre_key = key;
		}
	}
	guilib_fb_unlock();
	keyboard_key_invert_dalay = 0;
}

int keyboard_key_reset_invert(int bFlag, unsigned long ev_time)
{
	static unsigned long start_time;
	int rc = 0;

	if (pre_key)
	{
		if (bFlag == KEYBOARD_RESET_INVERT_DELAY)
		{
			start_time = ev_time;
			keyboard_key_invert_dalay = 1;
			rc = 1;
		}
		else if (bFlag == KEYBOARD_RESET_INVERT_CHECK && keyboard_key_invert_dalay)
		{
			unsigned long stay_time_ticks;

			if ((kb_mode > KEYBOARD_PHONE_STYLE) &&
			    multi_selection_key(pre_key))
				stay_time_ticks = seconds_to_ticks(PHONE_STYLE_KEYIN_BEFORE_COMMIT_TIME);
			else
				stay_time_ticks = seconds_to_ticks(KEY_BUBBLE_STAY_TIME);
			if (time_diff(timer_get(), start_time) > stay_time_ticks)
			{
				bFlag = KEYBOARD_RESET_INVERT_NOW; // reset invert immediately
			}
			else
				rc = 1;
		}

		if (bFlag == KEYBOARD_RESET_INVERT_NOW)
		{
			guilib_fb_lock();
			if (*pre_key->key == ' ' || *pre_key->key == WL_KEY_BACKSPACE || isupper(*pre_key->key) ||
			    kb_mode > KEYBOARD_PHONE_STYLE ||
			    (*pre_key->key == WL_KEY_NLS && display_mode != DISPLAY_MODE_WIKI_SELECTION))
				keyboard_process_key_invert(pre_key, true);
			else if (*pre_key->key != WL_KEY_NLS)
				restore_key_bubble();

			bIsKoreanSpecialKey = 0;
			bKoreanSpecialKeyEnabled = 0;
			if (kb_mode == KEYBOARD_NUM && ((!b_first_123_keyin && *pre_key->key == ' ') || *pre_key->key == '\''))
			{
				keyboard_set_mode(wiki_default_keyboard());
				guilib_fb_lock();
				keyboard_paint();
				guilib_fb_unlock();
			} else if (b_first_123_keyin)
				b_first_123_keyin = 0;

			pre_key = NULL;
			if (KEYBOARD_NONE < kb_mode && kb_mode < KEYBOARD_PHONE_STYLE)
				search_to_be_reloaded(SEARCH_TO_BE_RELOADED_CHECK, 0);
			guilib_fb_unlock();
		}
	}
	return rc;
}

int keyboard_korean_special_key(void)
{
	int rc = 0;

	if (kb_mode == KEYBOARD_CHAR_KO && pre_key && bIsKoreanSpecialKey && !bKoreanSpecialKeyEnabled)
	{
		if (time_diff(timer_get(), key_bubble_start_time) > seconds_to_ticks(KOREAN_SPECIAL_KEY_CHANGE_TIME))
		{
			unsigned char s[2];
			s[0] = toupper(*pre_key->key);
			s[1] = '\0';
			draw_key_bubble(pre_key->left_x_inverted, pre_key->left_y_inverted, pre_key->right_x_inverted, pre_key->right_y_inverted,
					s, 1);
			bKoreanSpecialKeyEnabled = 1;
		}
		else
			rc = 1; // check again later
	}
	return rc;
}

int keyboard_adjacent_keys(struct keyboard_key *key1, struct keyboard_key *key2)
{
	if (((key1->left_x == key2->left_x || key1->right_x == key2->right_x) && // same column
	     (key1->left_y - key2->right_y == 1 || key2->left_y - key1->right_y == 1)) || // adjacent row
	    ((key1->left_y == key2->left_y || key1->right_y == key2->right_y) && // same row
	     (key1->left_x - key2->right_x == 1 || key2->left_x - key1->right_x == 1))) // adjancent column
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

struct keyboard_key *keyboard_locate_key(char keycode)
{
	int i;
	struct keyboard_key *keyboard_key = NULL;
	int keyboard_entries = 0;

	if (kb_mode == KEYBOARD_CHAR)
	{
		if (wiki_is_japanese() || wiki_is_korean())
		{
			keyboard_key = qwerty_full_char;
			keyboard_entries = ARRAY_SIZE(qwerty_full_char);
		}
		else
		{
			keyboard_key = qwerty_char;
			keyboard_entries = ARRAY_SIZE(qwerty_char);
		}
	}
	else if (kb_mode == KEYBOARD_CHAR_JP)
	{
		keyboard_key = qwerty_char;
		keyboard_entries = ARRAY_SIZE(qwerty_char);
	}
	else if (kb_mode == KEYBOARD_CHAR_KO)
	{
		keyboard_key = qwerty_char;
		keyboard_entries = ARRAY_SIZE(qwerty_char);
	}
	else if (kb_mode == KEYBOARD_CHAR_DA)
	{
		keyboard_key = qwerty_char_da;
		keyboard_entries = ARRAY_SIZE(qwerty_char_da);
	}
	else if (kb_mode == KEYBOARD_NUM)
	{
		keyboard_key = qwerty_num;
		keyboard_entries = ARRAY_SIZE(qwerty_num);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_JP)
	{
		keyboard_key = phone_jp;
		keyboard_entries = ARRAY_SIZE(phone_jp);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_TW)
	{
		keyboard_key = phone_tw;
		keyboard_entries = ARRAY_SIZE(phone_tw);
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_ABC)
	{
		if (wiki_is_TC())
		{
			keyboard_key = phone_tw_abc;
			keyboard_entries = ARRAY_SIZE(phone_tw_abc);
		}
		else
		{
			keyboard_key = phone_abc;
			keyboard_entries = ARRAY_SIZE(phone_abc);
		}
	}
	else if (kb_mode == KEYBOARD_PHONE_STYLE_123)
	{
		if (wiki_is_TC())
		{
			keyboard_key = phone_tw_123;
			keyboard_entries = ARRAY_SIZE(phone_tw_123);
		}
		else
		{
			keyboard_key = phone_123;
			keyboard_entries = ARRAY_SIZE(phone_123);
		}
	}
	else if (kb_mode == KEYBOARD_CLEAR_HISTORY)
	{
		keyboard_key = clear_history;
		keyboard_entries = ARRAY_SIZE(clear_history);
	}
	else if (kb_mode == KEYBOARD_PASSWORD_CHAR)
	{
		keyboard_key = password_char;
		keyboard_entries = ARRAY_SIZE(password_char);
	}
	else if (kb_mode == KEYBOARD_PASSWORD_NUM)
	{
		keyboard_key = password_num;
		keyboard_entries = ARRAY_SIZE(password_num);
	}
	else if (kb_mode == KEYBOARD_RESTRICTED)
	{
		keyboard_key = restriction;
		keyboard_entries = ARRAY_SIZE(restriction);
	}
	else if (kb_mode == KEYBOARD_FILTER_ON_OFF)
	{
		keyboard_key = filter_on_off;
		keyboard_entries = ARRAY_SIZE(filter_on_off);
	}
	else if (kb_mode == KEYBOARD_FILTER_OPTION)
	{
		keyboard_key = filter_option;
		keyboard_entries = ARRAY_SIZE(filter_option);
	}

	if (keyboard_key)
	{
		unsigned char *s;
		for (i = 0; i < keyboard_entries; ++i) {
			s = full_alphabet_to_half(keyboard_key[i].key, NULL);
			if (*s == keycode) {
				return &keyboard_key[i];
			}
		}
	}

	return NULL;
}

int multi_selection_key(struct keyboard_key *key)
{
	unsigned char first_utf8_char[5];

	unsigned int len = strlen((const char *)key->key);
	get_first_utf8_char(first_utf8_char, key->key, len);
	return strlen((const char *)first_utf8_char) != len;
}
